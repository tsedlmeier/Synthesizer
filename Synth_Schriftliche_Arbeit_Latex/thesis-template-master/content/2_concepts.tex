\chapter{Konzepte}
\label{ch:concept}
\section{Subroutinen}
Bei klassischen Subroutinen findet ein statisches Scheduling Anwendung. Dies bedeutet, dass die Ausführ-Reihenfolge als geradliniger Ablauf vordefiniert ist. Ein Abweichen von dieser Reihenfolge ist ohne Programmänderung oder IF-Verzweigung nachträglich nicht mehr möglich. Oft wird diese Art von Routinen für zeitgesteuerte oder synchron ablaufende Vorgänge verwendet. Durch den strikten Ablauf ist die Planung besonders einfach und Probleme wie Dead- oder Livelocks sind nicht möglich. Nachteilig ist jedoch, dass auf spontane Ereignisse nicht besonders gut reagiert werden kann. So müssen Variablen oder beispielsweise hardwareseitige IOs mittels Polling zyklisch abgefragt werden, was zu einer erheblichen Erhöhung der Laufzeiten führen kann\cite[S.~4-6]{Prof.Dr.Ing.JurgenKrumm.2021}.
Klassische Subroutinen verfügen, vereinfacht betrachtet, nur über einen einzigen Einstiegspunkt. Sie können mittels Argumenten oder Variablen mit Informationen versorgt werden und können Informationen am Funktionsende zurückgeben. Beim Aufruf einer Funktion in einem Programm oder durch eine andere Funktion wird zunächst der derzeitige Zustand bzw. der Kontext gesichert. Die aufgerufene Funktion erstellt darauf einen neuen Kontext, welcher nur während der Durchführung der Subroutine gilt. Nach Abarbeitung der Funktion sind die lokal existierenden Variablen der Funktion nicht mehr verfügbar und der Zustand vor Ausführung der Funktion wird über den gespeicherten Kontext wiederhergestellt.\\
In Python werden solche Funktionen mit dem reinen def-Befehl erzeugt. Dies führt zur Erstellung eines Funktionsobjektes mit entsprechendem Namen und Inhalt. Bei Aufruf der Funktion werden die Anweisungen der Funktion abgearbeitet und erst, wenn die letzte Befehlszeile ausgeführt wurde oder ein return-Befehl folgt, endet der Funktionsaufruf \cite[S.~113-116]{Prof.Dr.Ing.JurgenKrumm.2021b}.\\
Im folgenden Beispiel ist eine simple Funktion ``summierFunktion\textunderscore 1'' mit den beiden Übergabeparametern ``uebergabeParA'' und ``uebergabeParB'' aufgezeigt. Die Funktion dient lediglich zum besseren Vergleich mit den noch folgenden Funktionskonzepten.\\
\begin{lstlisting}[language=Python,caption={Beispiel f"ur Funktionsdefinition als Subroutine},captionpos=b]
def summierFunktion_1(uebergabeParA, uebergabeParB):
    summe = uebergabeParA + uebergabeParB    
    return summe
\end{lstlisting}

\section{Koroutinen}
Der Begriff der Koroutinen wurde ursprünglich von Melvin Conway im Jahre 1963 ins Leben gerufen. Diese werden von ihm als gleichberechtigte Subroutinen beschrieben. Als besonders nützlich werden sie für nicht synchron ablaufende Kommunikationen zwischen einzelnen Programmen oder Funktionen angesehen \cite[S.~396]{Conway.1963}. Im Gegensatz zur sequentiellen Programmabfolge von Subroutinen werden Koroutinen genutzt, um kooperatives Multitasking zu ermöglichen. Kooperativ bedeutet, dass in diesem Fall die Routinen selbst die belegten Ressourcen (Prozessor etc.) wieder freigeben müssen, damit eine andere Routine diese wieder nutzen kann. Durch diesen Sachverhalt gilt das Kooperative Multitasking als einfach realisierbar \cite[S. 9-14]{Prof.Dr.Ing.JurgenKrumm.2021}.
Darüber hinaus verfügen Koroutinen nicht nur über einen Einstiegspunkt sondern können ihre Ausführung anhalten und an einem späteren Zeitpunkt wieder fortsetzen, was eine dauerhafte Kontextsicherung nötig macht. Eine Koroutine muss also nicht zwingend durch eine main-Funktion aufgerufen werden. Koroutinen verhalten sich ähnlich wie Generatoren, jedoch mit dem Unterschied, dass diese nicht nur Generieren können, sondern auch Daten konsumieren können. Beliebt sind Koroutinen, weil einfach Erzeuger-Verbraucher-Konstrukte möglich sind. Als Schlüsselbegriff dient bei Koroutinen der Ausdruck ``yield'', dieser wird als Ausdruck in der Funktion verwendet \cite{AtulKumar.2021}. Trifft die Koroutine auf einen ``yield''-Ausdruck, so pausiert die Routine. Erst wenn mittels eines ``send''-Befehles Daten an die Koroutine übermittelt werden, wird mit der Ausführung fortgefahren \cite{PythonSoftwareFoundation.d}. Die genauere Verwendung wird in Kapitel 3.1 beschrieben.

\section{Threads}
Bei Threads handelt es sich um ein ähnliches Konzept wie bei den Koroutinen. Hier entscheidet jedoch nicht der Programmierer wann ein Thread-Wechsel erfolgt oder das Programm selbst, sondern dies wird über den Scheduler des Betriebssystems bestimmt \cite{AtulKumar.2021}. Ein Thread ist dabei ein Bestandteil eines Prozesses, der scheinbar parallel zum Hauptprozess läuft. Neben den Kontext-Informationen des Haupt-Prozesses (``Process Control Block'') werden im jeweiligen ``Thread Control Block'' auch alle nötigen Informationen der dazugehörigen Threads abgelegt, damit bei einem Thread-Wechsel durch das Betriebssystem dieser später wieder fortgesetzt werden kann\cite[S. 83]{Silberschatz.2003}. Aktionen, bei denen auf spontane Ereignisse gewartet wird, wie zum Bespiel auf externe IO-Aktionen, bieten sich zur Realisierung mit Threads an und können den Gesamtablauf des Prozesses merklich beschleunigen.
Realisiert wird dies mit dem ``threading''-Modul. Besonders wichtig bei der Verwendung von Thread-Funktionalitäten ist es, ein gleichzeitiges Zugreifen auf gemeinsame Ressourcen, sogenannte kritische Bereiche, zu verhindern. Dies kann über manuelle Synchronisation, wie im Thread-Beispiel im nächsten Kaptiel beschrieben, oder mit dem ``Lock''-Objekt erfolgen \cite{PythonSoftwareFoundation.}. Darüber hinaus müssen Livelock- oder Deadlock-Szenarien in Betracht gezogen werden. Ein Deadlock kann beispielsweise entstehen, wenn zwei Threads gegenseitig aufeinander warten bzw. mit Semaphoren benötigte Bereiche gesperrt sind. Dies hätte zur Folge, dass keiner der beiden Threads mit der Programmausführung fortfahren kann \cite[Kap. 32.5.3]{Ernesti.2018}. In Kapitel 3.2 wird der Aufbau von Threads weiter erläutert.

\section{Asyncio}
Mit Asyncio wird eine Python-Bibliothek angeboten, welche kooperatives Multitasking im Einzelprozess- und Einzelthread-Stil ermöglicht. Wie aus dem Namen ablesbar, bietet sich der Einsatz gerade im Bezug auf die Verwendung von I/O-Anwendungen an und ist dem Konzept der Koroutinen sehr ähnlich. Auch hier wird kooperatives Multitasking verwendet, um von Wartezeiten geprägte Abläufe zu beschleunigen. Mit der Einführung des asyncio-Paketes in der Python Version 3.4 wurde Pyhton um die Ausdrücke ``async'' und ``await'' erweitert. Das ``async''-Schlüssewort muss vor dem def-Ausdruck stehen und signalisiert, dass es sich um eine asynchrone Funktion handelt. Mittels ``await''-Aufruf wird die derzeit ausgeführte asynchrone Routine pausiert und auf den Rückgabewert der übergebenen Funktion gewartet. In der Zwischenzeit können andere Routinen mit ihrer Abarbeitung fortfahren. Wenn es sich bei der Funktion, auf die gewartet wird, um eine ``sleep''-Funktion handelt, ist der Geschwindigkeitsvorteil leicht ersichtlich \cite{PythonSoftwareFoundation.b}. Ein weiteres nützliches Feature des ``asyncio''-Paketes ist die Warteschlangen-Funktionalität, welche in Form der sogenannten ``queues'' vorliegt. Hier lassen sich per ``put()''-Befehl Elemente in die Schlange einreihen und können per ``get()'' entnommen werden. Dies ermöglicht somit eine simple Erzeuger-Verbraucher-Struktur \cite{PythonSoftwareFoundation.e}. Die genaue Verwendung des ``asyncio''-Paketes wird in Kapitel 3.3 beschrieben. 

